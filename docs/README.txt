━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        ソースコードジェネレータ for X680x0 version 4
            Copyright (C)1989-1992 K.Abe
            Copyright (C)1994-1997 R.ShimiZu
            Copyright (C)1997-2024 TcbnErik

───────────────────────────────────────


● disの概要

　dis は X680x0/Human68k 用の高機能逆アセンブラです。バイナリ形式の実行ファイ
ルからアセンブリ言語のソースファイルを生成することができ、ソースコードジェネレ
ータとも呼ばれます。

　dis はまず K.Abe 氏により Oh!X '90 6月号で DIS.X version 1.00d が発表され、
その Bug fix and version up 版が Free Ware として公開されました。同氏により
version 2.06β までのバージョンアップが行われ、その時点でサポートが終了しまし
た。

　その後 R.ShimiZu 氏が dis を 68010-68040 の命令やコプロセッサ命令に対応さ
せ、version 2.50 以降が公開されました。同氏は version 2.79 までのバージョンア
ップを行ない、同じようにサポートを終了しました。

　これを私 TcbnErik が引き継ぎ、68060 の命令に対応させるなどしたものが
version 2.80 以降です(それまで作成していた version 2.78 patchlevel 5 のベース
を version 2.79 に変更したものを version 2.80 としました)。

　version 3.10 以降からは M.Suzuki 氏の協力により、FreeBSD 上でも動作するよう
になりました(Human68k 用の実行ファイルを逆アセンブルします)。


●サポートについて

　version 2.80 以降に対する要望や不具合の報告は TcbnErik 宛てにお願いします。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        著作権及び保証の有無

───────────────────────────────────────

　著作権及び保証については、K.Abe 氏は dis version 2.06β の README.DOC に以下
のように述べています。

==== ここから ====
［無保証］

  DIS は、正しく動作することを望んで作られていますが、動作の保証はいた
しません。DIS・DIS によって作られたソースプログラム・その実行ファイル・
及びこれらに準じるものによって被ったいかなる損害についても、作者は関知
いたしません。ユーザーの責任で使用して下さい。しかし本プログラムの動作
に異常/不都合が発見された場合は、作者まで連絡を下さると幸いです。でき
る限り対応したいと思います。


［著作権］

　本プログラムはフリーウェアとします。著作権は留保しますが、コピー・転
載・改造は自由です。ただしアーカイブからファイルを削除しての転載は遠慮
願います。
==== ここまで ====

　また、R.ShimiZu 氏は dis version 2.79 の README2.DOC で以下のように述べてい
ます。

==== ここから ====
 DIS v2.06β に準ずるものとします。したがって無保証です。著作権は、大
半が安倍氏のもの、680x0化対応改造部分が私(しみずりょう)のものとして保
留されます。
 コピー・改造・転載は自由に行うことができます。
 本プログラムはフリーウェアとします。
==== ここまで ====

　dis version 3.17 以降については、GNU General Public Licence の verison 3 ま
たはそれ以降のバージョンに従います。自由、かつ、無保証となります。

　著作権に関しては、dis version 2.06β までに記述された部分を K.Abe 氏が、
version 2.79 までで変更された部分を R.ShimiZu 氏が所有します。version 2.80 以
降及び、その前身である version 2.78 patchlevel 1～5 での変更部分は TcbnErik が
著作権を所持します。

　なお、このファイルは dis version 2.06β の README.DOC、dis version 2.79 の
README2.DOC を参考にしています。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        アーカイブの内容

───────────────────────────────────────

　Human68k 版の dis の公式配布書庫には以下のファイルが含まれます。

bin/dis.x       dis 本体(Human68k 用、X680x0 全機種対応)

docs/README.txt      このドキュメント
docs/labelfile.txt   ラベルファイルの仕様書
docs/table.txt       テーブル記述ファイルに関するドキュメント
docs/tablefile.txt   テーブルファイルの仕様書
docs/analysis.txt    コード解析に関する覚書
docs/gpl-3.0         ライセンス(GNU GENERAL PUBLIC LICENSE Version 3)

include/*       dis 用インクルードファイル(他のものを使っても構いません)。
                ※dis 2.79 以下では使用できません。

　ソースコードは以下のファイルが同梱されているか、またはライセンスに従い同じ場
所で配布されています。GitHub のリポジトリから入手することもできます。

src/*           dis のソースコード類
src/avl/*       AVL ライブラリのソースコード類
src/ports/*     移植用 Makefile と解説


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        準備

───────────────────────────────────────

　配布に実行ファイルが含まれている場合、dis をパスの通ったディレクトリに置き、
環境変数を設定するだけで使用できるようになります。実行ファイルがない場合は各自
で make して下さい。


●インクルードファイルの設定

　dis は起動するとまず DOS/IOCS/FPACK ファンクションコールの名称を収得する為に
各コールを定義したインクルードファイルを読み込みます。それぞれのファイルは
doscall.mac/iocscall.mac/fefunc.mac に対応し、必ず存在しないと逆アセンブルがで
きません。それらの存在するパス名を環境変数 dis_include もしくは include に設定
して下さい。dis_include の方から優先してファイルが検索されます。

　ただし -Y オプションを指定した場合は、それらのパスに先立ってカレントディレク
トリからファイルを検索します。

　また、SX-Window 対応モードで起動した場合は SX ファンクションコールの名称を収
得するために sxcall.mac も読み込みます。ファイル名をフルパスで環境変数
dis_sxmac に設定して下さい。

　fefunc.mac は XC ver 1 の fefunc.h に相当します。dis version 2.79 までは
fefunc.h か、それを fefunc.dis にリネームしたものを参照していましたが、XC ver
2 の fefunc.h では使えないなどの混乱が生じたため、fefunc.mac として提供するこ
とにしました。dis のアーカイブに同梱されている include ディレクトリの
fefunc.mac を前述の環境変数で指定したパスにコピーして下さい。同ディレクトリに
はその他のインクルードファイルも納めているので、必要ならそれらも使って下さい。

　なお、dis version 2.79 までで使っていた fefunc.h や fefunc.dis も問題なく使
えるので、リネームするなりリンクを張るなりしても結構です。


●オプションの設定

　dis は以下の環境変数を参照します。

DIS_OPT
    　dis version 4.00 で追加された環境変数です。DIS_OPT が設定されていない場
    合は dis_opt を参照します。

    　デフォルトの dis のオプションを指定します。この環境変数で指定したオプシ
    ョンはコマンドラインより先に解釈されます。出力関係のオプション等、常に付け
    るオプションを設定しておくと便利でしょう。なお、この環境変数で設定されたオ
    プションは、上書き指定が可能なもの(-m 等)を除きコマンドラインからの取り消
    しはできません。

    　オプションの詳細については後述のオプションの項を参照して下さい。

dis_opt
    　デフォルトの dis のオプションを指定します。環境変数 DIS_OPT が設定されて
    いない場合にのみ参照されます。dis version 3.16 までは dis_opt だけを参照し
    ていました。

    　dis の旧バージョンを併用する場合、新バージョンで追加されたオプションを
    dis_opt に設定してしまうと旧バージョンの実行時にエラーとなってしまいます。
    そこで、新バージョン用のオプションを DIS_OPT に、旧バージョン用のオプショ
    ンを dis_opt に設定することで併用を可能にします。併用しない場合は dis_opt
    に新バージョン用のオプションを設定しても構いません。

dis_include
include
    　doscall.mac、iocscall.mac、fefunc.mac のあるディレクトリのパス名を設定し
    ておいて下さい。dis_include の方を先に見ます。

    　--include-XXX-mac=file オプションでコマンドラインから違うファイルを読み
    込むように指定したり、--exclude-XXX-mac オプションでファイルを読み込まず、
    ファンクションコールの逆アセンブルも行わないようにすることができます。

dis_sxmac
    　SX-Window 用のインクルードファイル(アセンブラ用)のファイル名をフルパスで
    設定しておけば -u1 オプション指定時に SX-Window の A line trap を
        SX      __TSExit
    のように出力できます。

dis_header
    　出力ファイルの最初に出力される .include 部を書いたファイルのファイル名を
    フルパスで設定しておけば、そのファイルの内容がデフォルトの .include の代わ
    りに挿入されます。デフォルトの出力内容は
        .include        doscall.mac
        .include        iocscall.mac
        .include        fefunc.mac
    です(ファイル名は実際に読み込んだファイルのフルパスになります)。

    　また、-u1 オプション指定時に環境変数 dis_sxmac を設定している場合には
        .include        $dis_sxmac
    も追加されます。

    　--header=file オプションでコマンドラインから違うファイルを読み込むように
    指定することができます。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        使用法

───────────────────────────────────────

　以下の通りです。出力ファイル名を省略するか、"-" を指定した場合は標準出力に出
力します。出力ファイル(ソースコード/ラベルファイル両方とも)が既に存在すると上
書きするか問い合わせます。

    dis [option] 実行ファイル名 [出力ファイル名]


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        オプション解説

───────────────────────────────────────

　スラッシュ('/')はパスデリミタとして認識されるので、ハイフン('-')しか使用でき
ません。大文字、小文字は区別されます。

　省略可能な引数を受け取るオプションに引数を指定する場合は、間にスペース等を入
れないで下さい。オプションの直後に文字が記述されていないと、引数が省略されたも
のと見なされます。

　オプションは環境変数 DIS_OPT または dis_opt に設定しておくこともできます。コ
マンドラインと両方見るので、良く使うオプションを書いておくと便利かもしれません。


●命令セットに関するオプション

-m num
    　逆アセンブル対象の MPU を指定(num=68000～68060)。

    　逆アセンブルする命令セットを選択します。-m68040～68060 指定時は内蔵コプ
    ロセッサ・MMU 命令も使用可能になります。

    　-m68000,68030 のように複数の MPU を指定すると、指定した全ての MPU の命令
    セットが同時に使用可能になります。また、-m680x0 を指定すると選択可能な全て
    の MPU の命令セットが採用されます。

-m cpu32
    　CPU32 命令を有効にする。

    　CPU32 の追加命令 lpstop、tbls(n)、tblu(n) を逆アセンブルできるようにしま
    す。.cpu の切り換えは行ないません。

-m 68851
    　68851 命令を有効にする(-m68020 指定時のみ有効)。

    　外付け MMU 命令を逆アセンブル可能にします。

    　このオプションは -m680*0 オプションによってクリアされるので、それより後
    に指定して下さい。

-m 6888x[,ID]
    　有効な FPCP とその ID を指定(68881/68882 ID=[1],2-7)。

    　-m68020～68030 を指定している場合に、外付けコプロセッサ命令を逆アセンブ
    ル可能にします。-m68881 と -m68882の機能は全く同じです。

    　ID の指定を省略した場合は1と見なされます。-m68881 -m68882,2 のように複数
    のIDを指定することも出来ます。

    　このオプションは -m680*0 オプションによってクリアされるので、それより後
    に指定して下さい。

--fpsp
    　未実装浮動小数点命令を有効にする(デフォルト)。

--no-fpsp
    　未実装浮動小数点命令を無効にする。

    　通常は、システムによってソフトウェアエミュレーションされることが保証され
    ている命令は実在する命令と見なされますが、このオプションを指定した場合は未
    定義命令と見なします。

--isp
    　未実装整数命令を有効にする(デフォルト)。

--no-isp
    　未実装整数命令を無効にする。

    　通常は、システムによってソフトウェアエミュレーションされることが保証され
    ている命令は実在する命令と見なされますが、このオプションを指定した場合は未
    定義命令と見なします。

--no-fpu
    　内蔵 FPU 命令を無効にする(-m68040～68060 の後に指定)。

--no-mmu
    　内蔵 MMU 命令を無効にする(-m68030～68060 の後に指定)。

    　通常は -m680*0 オプションで指定した MPU によっては、自動的に内蔵 FPU/MMU
    命令が有効になります。これらのオプションを指定するとそれらの命令を対象命令
    セットから除外します。

    　逆アセンブルするファイルにそれらの命令が含まれていないと分っている場合、
    このオプションを指定することで命令セットを限定し、解析の手助けをすることが
    できます。

    　このオプションは -m680*0 オプションによってクリアされるので、それより後
    に指定して下さい。


●解析に関するオプション

-h
    　データ領域中の $4e75(rts のコード)の次のアドレスに注目する。

    　素直でないコーディングをしたプログラムの場合(!?!?)、出力ファイルにデータ
    の塊が残る場合があります。そのような場合はユーザーがラベルファイルを用いて
    dis の解析の「つっかかり」を与えれば良いのですが、このオプションを付けても
    たいていのところを解析してくれる筈です。

-i
    　分岐先で未定義命令等を発見しても呼び出し側をデータ領域にしない。

    　通常は「未定義命令のあるところに飛ぶような奴は俺はプログラムと認めねぇ」
    ですが、このオプションを付けると、「そんなことは俺の知ったことじゃねぇ」に
    なります(多分)。

-j
    　実行時にアドレスエラーの起こるであろう命令を未定義命令と見なさない。

    　通常は move.l (1),d0 等の、実行時にアドレスエラーが起こるであろう命令は
    未定義命令と見なしますが、このオプションを付けるとそのチェックをしません。
    なお、68020 以降の MPU では上に挙げた命令はアドレスエラーになりませんが、
    dis では未定義命令と見なします。普通のプログラムなら、効率的なメモリアクセ
    スの為に偶数アドレスに整合しているので問題ないと思います。

-k
    　命令の中を指すラベルはないものと見なす。

    　命令の中を指すラベルの存在しないプログラムで、このオプションを指定すると
    生成ファイルの質が良くなる場合があります。しかし存在するプログラムで指定す
    ると生成ファイルの質がかなり悪くなります。

    　このオプションを付けると、label+$?????? と言うラベルを全て解消するため
    に、label+$?????? の含まれる領域はデータ領域とされます。例えば、

    top:    bsr     label3
            lea.l   (label1),a0
            move.w  (label2),d0
            rts
    label1: .dc.w   $0040   ;data
    label2: .dc.w   $0000   ;data
    label3: .............   ;program

    　上のプログラムは -k オプション無しだと
    top:    bsr     label3
            lea.l   (label1),a0
            move.w  (label1+$000002),d0
            rts
    label1: ori.w   #$0000,d0
    label3: .............

    　-k オプションを付けると
    top:    bsr     label3
            lea.l   (label1),a0
            move.w  (label2),d0
            rts
    label1: .dc.b   $00,$40
    label2: .dc.w   $0000
    label3: .............

    　とりあえず、-k オプションを付けずにソースジェネレートしてみておかしいと
    ころがあれば、-k オプションを付けてやってみて、2つを比較してみると良いでし
    ょう。

-f
    　バイト操作命令の不定バイトのチェックをしない。

    　不定バイトチェック(不定バイトが $00 か $ff かどうかのチェック)をしないよ
    うにします(不定バイトについては用語解説の項目を参照して下さい)。

    　このオプションを付けた場合、生成ファイルをアセンブルしたものが元の実行フ
    ァイルと等しくならない場合があります。

-E
    　バイト操作命令の不定バイトの書き換えチェックをしない。

    　不定バイトに対するラベルが存在した場合、通常は、「不定バイトを書き換える
    ような奴はいないよなぁ」と信じてその命令(不定バイトのある)領域をデータ領域
    にしてしまいますが、-E オプションはこのチェックをしないようにします。

-u[num]
    　A line trap 及び DOS call、浮動小数点演算ドライバ(FLOATn.X)で使用されて
    いない F line trap を未定義命令と見なさない。

    　Mac Emulator や、SX-Window 等の A line trap を使ったプログラムをソースジ
    ェネレートするときに付けて下さい。

    　なお、使用されているかどうかの判断は、doscall.mac、fefunc.mac にシンボル
    が存在するかどうかによります。

    　-u1 の時、SX-Window 対応となります。環境変数 dis_sxmac をセットしておけ
    ば、SX-Window のファンクションコールを、SXCALL name のような形で出力しま
    す。

-y
    　「text セクション中の全てのデータ領域をとりあえず逆アセンブルしてみて、
    おかしくなければそこをプログラム領域と思い込む」ことをしない。

    　dis のデフォルトでは、一通り解析した後、サイズの分からないデータは「プロ
    グラムちゃうか？」と疑って、片っ端から解析しようと試みます。-y オプション
    を付けると、「片っ端から」ではなく、データの終わりがリターン命令、ジャンプ
    命令等と見受けられるもののみを「プログラムちゃうか？」と疑います。

    　このオプションをつけると解析の対象となる領域が少なくなる分だけ、解析時間
    が減ります。しかしプログラム領域をデータ領域として残してしまうことが多くな
    るでしょう。しかし付けないと、データ領域をプログラム領域としてしまうことも
    あるかも知れません。

-n num
    　文字列として判定する最小の長さ(デフォルトは3)。

    　このプログラムでは、文字列領域を自動的に判別します。ただ、文字列判別を完
    璧に行うのは不可能で、文字列でないところも文字列としてしまう場合があります
    (特に短い文字列)。このオプションを指定すると、それ未満の長さは文字列として
    判定しません。また、num に 0 を指定すると、文字列の自動判別を行いません。

-D
    　データセクション中にもプログラムを認める。

    　データセクションに分岐するプログラムが存在することが分かったためにサポー
    トしました。データセクションに分岐していれば、「解析中のバックトラックの要
    因の表示機能」で、「pc が有効なセクションを外れた」と表示されるのでわかる
    と思います(他の理由でもそう表示されることはありますが)。プログラム領域解析
    中に「pc が有効な...」と表示されたらこのオプションを試してみて下さい。

    　該当するプログラムの例として以下のものがあります。
        DICM.X  OPMDRV.X  OPMDRV2.X  OPMDRV3.X

-R num
    　未使用フィールドのチェック項目の指定(ビット指定, 初期値=15)。

    +1  未使用レジスタフィールド(mul[us].l, ftst.x, c{inv,push}a)のチェック。
    +2  拡張アドレッシングでのサプレスされたレジスタフィールドのチェック。
    +4  サプレスされたインデックスレジスタに対するスケーリングのチェック。
    +8  サプレスされたインデックスレジスタに対するサイズ指定(.l)のチェック。

-G
    　サブルーチンコール命令の直後に引数を置くプログラムを解析する。

    　一般にサブルーチンに引数を渡す手段としてはスタックに積んだりレジスタに代
    入する方法が用いられますが、サブルーチンコール命令の直後に .dc 疑似命令な
    どで引数を置くという手法もあります(インラインパラメータと呼ばれているよう
    です)。主に古いコードで見られ、ROMDB などで使われています。

    　この手法が使われているプログラムの場合、dis は命令とデータを自動的に区別
    することができないため、その一帯を全てデータ領域にしてしまいます。

    　このオプションを指定すると、jsr、bsr などサブルーチンコール命令の直後に
    データラベルがあった場合、その時点でプログラムの解析を打ち切り、正しいプロ
    グラムと認めます。ただし自動的にデータラベルが登録されることはないので、ユ
    ーザによるラベルファイルの修正が必須となります。

    　ラベルファイルを読み込まない初回の逆アセンブル時は -G オプションは指定し
    ないで下さい。正しく解析が行われない可能性があります。

    ・ラベルファイルの修正方法

    　まず一度 -e オプションを指定して逆アセンブルし、ラベルファイルを作成しま
    す(この時 -G オプションは指定しないこと)。次に、不完全なソースコードを自分
    で解析しながら、サブルーチンコール命令の直後にある引数を探します。そのデー
    タのアドレスを計算し、ラベルファイルに追加します。

    　今度は -g、-G オプションを指定して逆アセンブルします。ラベルファイルの指
    定が正しければ、追加したアドレスの直前までがプログラムとして、追加したアド
    レス以降がデータとして解析されるはずです。

--reltbl-zero=num
    　リラティブオフセットテーブルのオフセット値として0を認めるかどうかを指定
    します。

    --reltbl-zero=0 0を認めません。
    --reltbl-zero=1 先頭のみ認めます(デフォルト)。
    --reltbl-zero=2 テーブル全域で認めます。

--movem-zero=num
    　レジスタリストが全て0の movem 命令(以下 movem #0)を未定義命令と見なさな
    い。

    　レジスタリスト形式による表記はできないため、即値形式で movem.l #0,-(sp)
    のように出力されます。

    --movem-zero=0 movem #0 を未定義命令と見なします(デフォルト)
    --movem-zero=1 movem #0 を未定義命令と見なしません。


●ファンクションコールに関するオプション

--exclude-doscall-mac
--exclude-iocscall-mac
--exclude-fefunc-mac
    　それぞれ DOS コール、IOCS コール、FEFUNC コールを認識しないようにしま
    す。DOS/FEFUNC コールは全て未定義命令か .dc 疑似命令(-u 指定時)に、IOCS
    コールは moveq + trap #15 で出力されます。

    　このオプションは X680x0/Human68k 以外の環境の実行ファイルを逆アセンブル
    する時に、余計な解釈を行わないようにする為に使用します。

--include-doscall-mac=file
--include-iocscall-mac=file
--include-fefunc-mac=file
    　それぞれ DOS コール、IOCS コール、FEFUNC コールのマクロ/ファンクションコ
    ール番号を定義したファイルを指定します。file にファイル名を記述して下さ
    い。無指定時は環境変数 dis_include か include で指定したディレクトリにある
    ファイルが読み込まれます。

    　このオプションは環境変数 dis_include、include よりも優先されます。


●出力ファイルに関するオプション

-b num
    　分岐命令のサイズを以下のようにする(分岐命令のサイズとは Bcc 等の .s/.w.l
    のことです)。

    -b0 ショートブランチで済むのにワードブランチをしている、またはワードブラン
        チで済むのみロングワードブランチをしている場合(デフォルト)。
    -b1 サイズを常に省略します。
    -b2 サイズを常に付けます。

-o num
    　文字列領域の桁数(デフォルトは 60)。

    　ソースファイルに出力する文字列領域の桁数を指定します。

-w num
    　データ領域の横バイト数(デフォルトは8)。

    　データ領域の横バイト数を指定します。デフォルトでは
        .dc.b   $??,$??,$??,$??,$??,$??,$??,$??
    のように横は8バイトです。データの多いプログラムでは16にした方が良いかもし
    れません。

-a[num]
    　num 行ごとにアドレスをコメントで出力。

    　num を省略すると5行ごと。ラベルファイル(後述)を編集する時等は便利かもし
    れません。

-r
    　文字列に16進数のコメントを付ける。

-x
    　オペコードに16進数のコメントを付ける。

    (例)
        ori.b   #xx,d0          ;$0000,$00xx
        rts                     ;$4e75
    のようになります。

-s[num]
    　外部定義シンボルについて、定数の定義行及びアドレス値の外部宣言行を出力す
    る。

    　実行ファイルにシンボルテーブルが付属している場合、シンボル名とアドレス値
    または定数が得られます。これらの情報は再アセンブルの際にはなくても問題あり
    ませんが、シンボルテーブルまで再現するには外部定義しなければなりません。ア
    ドレス値についてはラベルを "::" で定義するのでシンボルテーブルに出力されま
    すが、定数は .equ 疑似命令で定義しなければなりません。このオプションは定数
    を定義するかを指定します。

    　また、アドレス値はラベル定義時に同時に外部定義されるのですが、シンボルテ
    ーブルに現われる順番と、実際にソースコードに現われる順番が違うとシンボルテ
    ーブルが一致しません。そのような場合、シンボルテーブルに現われる順番通りに
    .xref 疑似命令でラベルを宣言すると順番まで再現されます。このオプションでは
    宣言を行うかどうかも指定できます。

    　定数の定義は「name:: .equ 値」、ラベルの宣言は「 .xref name」という形式
    でソースコードの先頭部分に出力されます。なお、'*'+ファイル名+'*' という形
    式のアドレス境界情報のシンボルはアセンブラで扱う事が出来ないので、常に無視
    されます。

    数値を省略した場合は -s0 と見なします。標準設定は -s1 です。

    -s0 外部定義シンボルの定義行を出力しません。
        ただし、アドレス値については各セクションで定義される時に外部定義される
        ので、-C0 や -C1 オプションを指定しない限り常に外部定義になります。

    -s1 定数のみ定義行を出力します。定数の外部定義シンボルについては、定義され
        る順番も含めてシンボルテーブルが再現されます。

    -s2 アドレス値についても、.xdef 疑似命令による外部定義を出力します。全ての
        シンボルについて、定義される順番も含めてシンボルテーブルがほぼ完全に再
        現されます。

        ただし、スタックセクション(属性 0x0204)及びコモンセクションのシンボル
        (同 0x0003)は再現できず、BSS のシンボル(同 0x0203)となってしまいます。

    　-e オプションで出力されたラベルファイルのシンボル名を書き換えて -g オプ
    ションで読み込ませる場合は、-s2 は指定しないで下さい。.xdef で宣言されるシ
    ンボル名は実行ファイルに付属するシンボルテーブルそのままであるのに対し、ソ
    ース中で定義/参照されるのはラベルファイルで変更されたシンボル名なので、ア
    センブルしようとするとエラーになってしまいます。

-F
    　dbra、fdbra を dbf、fdbf として出力する。

-X
    　16進数を大文字化する。

-U
    　オペコード等を大文字化する。

-Z[num]
    　16進数をゼロサプレスする。

    -Z0 普通にゼロサプレスする。
    -Z1 ゼロサプレスした時省略可能な '$' を省略する。

    　num を省略した場合は -Z0 と同じになります。

-N
    　デフォルトのサイズならサイズを出力しない。

    (例)
        move.w  #$1234,d0 (default)
        ↓
        move    #$1234,d0

-K char
    　コメントキャラクタを変更。

    　コメントの先頭には通常 ';' がつきますが、それを変更出来ます。'#' にした
    ければ、-K# と指定して下さい。

-L char
    　ラベルの先頭文字を変更。

    　ラベルの先頭には通常 'L' がつきますが、それを変更出来ます。'_' にしたけ
    れば、-L_ と指定して下さい。

-C
    　ラベルの後のコロン(:)を出力するかどうか。

    -C0 ラベルの後にコロンを付けない。
    -C1 ラベルの後にコロンを1つ付ける。
    -C2 ローカルラベルにはコロンを1つ、外部定義ラベルにはコロンを2つ付ける(デ
        フォルト)。
    -C3 すべてのラベルの後にコロンを2つ付ける。

-A
    　cmpi、movea 等を cmp、move 等にする。

    　ただし、演算先がデータレジスタの cmpi、ori、andi、subi、addi、eori は
    "i" なしの命令とオブジェクトコードが異なるので、そのままで出力されます。ま
    た、addi と subi で即値が 1～8 の場合、addqや subq に最適化されるのを防ぐ
    ため、即値にサイズが付きます。

-S[num]
    　出力ファイルを分割して出力する。

    　実行ファイルの(ほぼ)num KByte ごとに出力ファイルを分割します。数100KByte
    の実行ファイルをソースジェネレートする時に付けると、あとから見易いかも知れ
    ません(そのままではアセンブル出来ませんが)。

    　分割されたファイル名は以下のようになります。
        text section は、拡張子が以下のようになります。
            .000 .001 ... .009 .00a .00f .010 ...

        data section、bss は拡張子がそれぞれ .dat .bss になります。

    　num を省略すると 64KByte ごとに分割します。ファイルの分割は空行で行われ
    るので、サブルーチンの途中で切れたりと言うことはそんなには無いと思います。

-B
    　bra の後でも改行する。

    　既定ではリターン命令およびプログラムを終了させるファンクションコールの後
    に一行空行が入りますが、このオプションを指定すると bra および fbra の後に
    も空行を入れます。

        リターン命令: rte  rtd  rts  rtr
        DOS コール: _EXIT  _EXIT2  _KEEPPR  _KILL_PR
        SXCALL: __TSExit (ExitToShell)

-M
    　cmpi、move、addi.b、subi.b #imm および pack、unpk にコメントを付ける。

    　num が表示可能な ASCII code の場合に以下のようなコメントを入れます。解析
    には便利でしょう。

        cmp.b #$40,d0         ;'@'

-W num
    　同一データを .dcb で出力する最小バイト数。0なら圧縮しない(初期値=64)。

    　データを .dc.? で出力する場合、全てのデータが同一の値であれば .dcb.? に
    より圧縮して出力されますが、一定のサイズより小さい領域は例え同一値であって
    も圧縮されません。このオプションでそのサイズの閾値を変更できます。

--a7
    　a7 レジスタを 'a7' と表記する(デフォルト)。

    　--sp オプションを取り消します。

--sp
    　a7 レジスタを 'sp' と表記する。

    　通常、スタックポインタは 'a7' と表記されますが、このオプションを指定する
    と 'sp' と表記されるようになります。

--new-syntax
    　アドレッシングを新表記で出力する(デフォルト)。

    　--old-syntax を打ち消します。

--old-syntax
    　アドレッシングを旧表記で出力する(標準では --new-syntax)。

    　通常は 68020 以降で定められたアドレッシング表記で出力しますが、このオプ
    ションを指定した場合は 68000 の表記で出力します。ただし、68020 以降でしか
    使用できないアドレッシングでは常に新しい表記で出力します。

--real
    　浮動小数点を実数表記で出力する(デフォルト)。

    　命令のオペランドやデータとして浮動小数点を出力する場合の表記を選択しま
    す。--real を指定すると「0f1.23e+10」といった実数表記で出力します。

    　非数や無限大、非正規化数、未使用ビットがセットされているデータの場合は実
    数表記が不可能なので、常に内部表現で出力されます。

    --inreal を打ち消します。

--inreal
    　浮動小数点を内部表現で出力する。

    　命令のオペランドやデータとして浮動小数点を出力する場合の表記を選択しま
    す。--inreal を指定すると「!4048f5c3」といった内部表現で出力します。

    --real を打ち消します。

--overwrite
    　ファイルを無条件で上書きする。

    　通常、指定した出力ファイルが既に存在した場合、上書きするかどうかを問い合
    わせますが、このオプションを指定すると問い合わせずに強制的に上書きします。

--header=file
    　出力ファイルの最初に出力される .include 部を書いたファイルを file に指定
    すると、そのファイルの内容がデフォルトの .include の代わりに挿入されます。
    環境変数 dis_header より優先されます。

--strip-include-path
    　.include にパス名を付けず、ファイル名のみを出力します。


●実行ファイルに関するオプション

-d
    　デバイスドライバの時に指定。

    　実行ファイルがデバイスドライバの時は必ず指定して下さい。ほんの僅かに生成
    ファイルの質が良くなります。デバイスドライバでないときは指定しないで下さ
    い。妙なことが起こるかもしれません。

    　-g オプション指定時はこのオプションは無視されます。

-z base,exec
    　指定した実行ファイルを単なるバイナリファイルと見なす。その際、そのファイ
    ルは base から読み込まれて exec から実行されるものとする。
    base、exec は16進数のみ。

    　例えば、2HD disk の IPL 部を読み出して解析するのなら、 
        dis 2hdipl 2hdipl.s -z2000,2000
    等と指定する。ROM の IPL/IOCS を解析するのなら、
        dis rom rom.s -zff0000,ff0010
    等と指定する(-h をつけた方が良いかも知れない)。

    (当然 IPL 等は db.x 等で Human68k のファイルに落としておかねばなりません)

    　少なくとも base は分かっていなければなりません。exec が分からなければ
    base と同じにしておいて、-h オプション等を付ければなんとか見れるソースにな
    ると思います。


●ラベルファイルに関するオプション

-e[filename]
    　ラベルファイルの出力。

    　ファイル名を指定しなければ、出力ファイルの拡張子を .lab に変更した名称の
    ファイルを作る。

-g[filename]
    　ラベルファイルの読み込み。

    　ファイル名を指定しなければ、出力ファイルの拡張子を .lab に変更した名称の
    ファイルを読み込む。


●テーブル記述ファイルに関するオプション

-T[filename]
    　テーブル記述ファイルの読み込み。

    　ファイル名を指定しなければ、出力ファイルの拡張子を .tab に変更した名称の
    ファイルを読み込む。


●その他のオプション

-q[num]
    　解析中/出力中のメッセージ( ><?#s!*.-+rRzt$ )を出力しない。

    -q0 通常の出力抑制。
    -q1 テーブルに関する情報も出力しない。

    　数値を省略した場合は -q0 と同じ。

    　出力しないとかなり速くなるので、大きいファイルをソースジェネレートする時
    はなるべく付けましょう。

        -- 文字の説明 --
        > 分岐命令等で、解析の深さが深くなった。
        < リターン命令等で、解析の深さが浅くなった。
        ? 未定義命令等を発見して、解析の深さが浅くなった。
        # データ。
        s 文字列。
        ! ラベルチェックで、命令の中のラベルを発見した。
        * ラベルチェックで、命令の中のラベルを解消した。
        . ラベル１つ。
        - そのままではプログラム領域からデータ領域に突入してしまう所を発見/修
          正した。
        + ラベルチェックでプログラム領域中に未定義命令等を発見した。
        r リラティブオフセットテーブル。
        R リラティブオフセットテーブル(ロングワード)。
        z ロングワードテーブル。
        t ユーザー指定のテーブル。
        $ BSS ラベル１つ。

    　なお、解析中に出力される {数値} というメッセージは解析で見つけたプログラ
    ム領域などの数です。これは -q オプションを付けても出力されます。

-v
    　単なる逆アセンブルリストを出力する。

    　このオプションはおまけです。db.x の出力をリダイレクトするよりは見易いか
    な…

-I
    　ラベルチェック中に、修正したアドレスを表示する。

    命令の中を差すラベル(X -> Y+?)
        　アドレス X が命令の中にあってラベルを振ることができないために、Y+?
        にするという意味。

    命令の中を差すラベル(X)データ領域に変更しました(Y-X)
        　-k オプションを使用している、あるいはアドレス X が不定バイトの上にあ
        るために、Y から X までをデータ領域に変更したという意味。この領域が本
        当にプログラムのようであれば -E オプションを試してみると良いかもしれな
        い。

-Q
    　環境変数 DIS_OPT、dis_opt を参照しない。

    　通常はコマンドラインを解釈する前に環境変数 DIS_OPT または dis_opt に設定
    したオプションを解釈しますが、このオプションを指定するとこれらを参照しませ
    ん。

    　コマンドラインの先頭に指定する必要があります。

-V num
    　解析中のバックトラックの要因の表示。

    -V0 出力しない(version 1.13 以前と同じ)。
    -V1 プログラム領域の筈のところでのバックトラックの要因を表示(デフォルト)。
    -V2 全ての領域でのバックトラックの要因を表示。

    　表示されるのは、dis がプログラムと認めなかった理由、およびそのアドレス等
    です。作者にしか意味が分からないかも知れません(^_^;)

-Y
    　カレントディレクトリからも include ファイルを検索する。

    　通常は環境変数 dis_include や include で指定されたパスにあるインクルード
    ファイルを読み込みますが、このオプションを指定するとカレントディレクトリに
    あるファイルを優先して読み込みます。カレントになければ環境変数で指定された
    パスを検索します。

--deterministic
    　決定論的逆アセンブルを行う。

    　入力ファイルの内容が同じなら、いつどこで実行しても同じ出力ファイルを生成
    するようになります。
        環境変数 dis_header を参照しません。
        ソースコードに実行ファイルのタイムスタンプと実行日時を出力しません。
        ソースコードに出力する dis の実行ファイル名を "dis" 固定にします。

    　同時に以下のオプションが指定されます。
        -Q -h -q -N -Z1 --sp --strip-include-path

    　コマンドラインの先頭に指定する必要があります。


●無用なオプション(バグがあったりして)

-c
    　ラベルチェックを行わない。

    　ラベルチェックとは主に「命令の中を指すラベルを捜す」作業です。-c オプシ
    ョンを付けると、この作業を行いません。付ける必要はありません。付けると命令
    の中を指すラベルが存在する場合、正常なソースが出力されない場合があります。

-l
    　プログラム領域が見つからなくなるまで何度も捜すことをしない。

    　このプログラムではデータ領域からプログラム領域が見つからなくなるまで捜し
    ますが、-l オプションをつけると一度しか捜しません。付ける必要はありませ
    ん。

-p
    　データ領域中のプログラム領域を判別しない。

    　一通り解析してプログラム領域とデータ(と思われる)領域に分けますが、データ
    (と思われる)領域の中にもプログラム領域がたいてい埋もれています。-p オプシ
    ョンを付けると、データ(と思われる)領域からプログラム領域を捜しません。付け
    る必要はまずありません。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        テーブル記述ファイルについて

───────────────────────────────────────

　dis はリラティブオフセットテーブルを除き、自動ではテーブルを認識することはで
きません。そこで、テーブルの形をユーザーが記述して dis に教えてやろうというの
がテーブル記述ファイルです。詳細は tablefile.txt 及び table.txt を参照して下さ
い(後者には間違いがいくつかあります)。

　dis version 2.83 以降では、限定的ながらもテーブルで浮動小数点を出力できま
す。使用できるのは以下の識別子です。

    dc.s (.dc.s)
    dc.d (.dc.d)
    dc.x (.dc.x)
    dc.p (.dc.p)

　dc.?[ 式 ] という形式も可能ですが、オペランド表現式は一切指定できません。こ
れらの命令は単に pc のデータを出力します。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        ラベルファイルについて

───────────────────────────────────────

　ラベルファイルは、各ラベル(=アドレス)の属性、シンボルネームを示すもので、-e
オプションで出力させることが出来ます。ラベルファイルを書き換えて、次に -g オプ
ションで、書き換えたラベルファイルを読み込ませることによってラベルファイルに従
ったソースファイルを生成することができます。

　なお、ラベルの属性を変える、ラベルを増やすのは構いませんが、減らすと正常なソ
ースが出来ないと思います。そのラベルはどこかで参照されていると思われるからで
す。

　ラベルファイルを妙な風に書き換えると、dis の動作が変になるかも知れません。ご
注意下さい。

　ラベルファイルのファイル名は -e/-g オプションの後に特に指定しなければ、実行
ファイル名の拡張子を .lab に変えたものになります。-e/-g オプションは同時に使用
できます。

　ラベルファイルの書式については labelfile.txt を参照して下さい。


●備考

　D の後に F という文字が付く場合があります。これは「絶対」を意味していて、D?F
なら「絶対にデータ」ということです。つまり、そこから解析してみてプログラムと見
なし得なかったことを示します。

　ユーザーが書き加える/書き変える属性文字列で、「絶対にデータ」と言うのなら f
を書いて下さい。f を書かないと、DIS はそこから「プログラムちゃうか？」と思って
しまうかも知れません。反対に単なる解析のつっかかりを与えるのであれば、du のみ
書いて下さい。dis はそこから「プログラムちゃうか？」と疑って調べてくれます。
dis の出力した F は別に消しても問題ない筈です。

　(重要) dis が出力する属性文字列は大文字ですが、ユーザーの書き加える属性文字
列は全て小文字でなければなりません。小文字にしないと、例えば P の場合、そのア
ドレスからは解析済みと見なしてしまいます。小文字にするとそこから解析するので、
うまくいきます。 D の場合も同様です。

　属性文字列の DZ は、.z ファイルや IOCS ROM 等でロングワードのテーブルをユー
ザーが指定するためにあります(.x ファイルではロングワードのテーブルは自動的に認
識します)。後の "IOCS ROM をソースジェネレートする方法" を参考にして下さい。
(注) この機能はテーブル記述ファイルで代用できます。

　ラベルファイル中のシンボル名を変更すれば、出力ソースの中でも変更されます。シ
ンボル名を新たに書き加えれば、そのアドレスは全てシンボル名に置換されます。シン
ボル名の最初が * ならばコメントと見なされてシンボル名にはなりません。

　C で doslib や iocslib 等を使うと、シンボルテーブルが残っていた場合、
doscall.mac や iocscall.mac に定義されているのと同名のラベルが出てくるときがよ
くあります(アセンブルすると redifinition error がでる)。そういうときはラベルフ
ァイルを出力して、同名のラベルを適当な違うラベル名に書き換えれば良い筈です。


●リラティブオフセットテーブル

　リロケータブルなプログラムでテーブルを作る時に良く用いられます。テーブルには
テーブルの先頭番地からのオフセットが符号付１ワードで書かれます。分岐テーブルに
良く用いられますが、データテーブルにももちろん使用可能です。GCC がテーブルを作
るときは大抵このようになっているようです。

    (例)
            add.w   d0,d0                   ;*2
            move.w  (table,pc,d0.w),d0
            jmp     (table,pc,d0.w)
    table:
            .dc.w   label1-table
            .dc.w   label2-table
            .dc.w   label3-table
            .dc.w   label4-table

　DIS は大抵のリラティブオフセットテーブルを自動的に認識しますが、少し手を抜い
ているので、認識しなければラベルファイルを書き変えなければならない場合があるで
しょう。データテーブルに使用した場合は自動的には全く認識できません。


● IOCS ROM をソースジェネレートする方法

　まず、db.x で IOCS ROM のイメージファイルを作ります(ROM は 1987年05月07日
version を基にしています)。

    db.x
    -wromimage,ff0000 ffdcff    #この ffdcff はかなりいい加減
    -q

　とりあえず、ソースジェネレートします。

    dis romimage rom.s -zff0000,ff0010 -e -h -q

　IOCS ROM の中の IOCS call のテーブルを dis に認識させるため、romimage.lab を
書き変えます。

    ff1b32  DUF  ->  ff1b32  dzf    #この f はいまのところ意味が無い

　また、次のところをプログラムと見なしてしまうので、そこも書き変えます。ff05ca
が P でなければ書き変える必要はありません。

    ff05ca  P    ->  ff05ca  duf    #この f は絶対必要

　もういちどソースジェネレートします(-e は付けなくても良い)。

    dis romimage rom.s -zff0000,ff0010 -g -e -h -q

　これで rom.s が出来ました。dis で簡単にできるのはここまででしょう。-e オプシ
ョンを付けていれば、ラベルファイルが更新されているはずですので、そこからまたラ
ベルファイルに変更を加えてソースジェネレートすることもできます。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        プログラムの解析について

───────────────────────────────────────

●未使用レジスタフィールド

    mulu.l  <ea>,Dn
    muls.l  <ea>,Dn
    ftst.x  FPn

　これらの命令コードには、レジスタを指定する為のフィールドが二つあるのですが、
片方のみ使用して、もう片方は未使用となっています。

　mulu.l <ea>,Dn の第二ワードは下のようなコードです。

    0???000000000???
      |           |
      |           +--- 未使用
      +--------------- レジスタ番号(Dn)

　この未使用なフィールド(本来レジスタペア用のもの)は、巷のアセンブラではレジス
タ番号と同じ数値が入るようです。例えば、mulu.l <ea>,d5 ならば、第二ワードは、
    0101000000000101
     ~~~         ~~~
となるようです。

　ftst.x FPn の第二ワードは

    000???_???0111010
        |   |
        |   +--------- 未使用
        +------------- レジスタ番号(FPn)

　こちらの未使用フィールドは HAS や fas,db などでは 0 が入るようですが、libc
のライブラリの中には何故かレジスタ番号と同じ数値が入ったものもあるようです。結
局、例えば ftst.x fp5 の第二ワードは、
    000101_0000111010    (HAS,fas,db)
       ~~~ ~~~
もしくは、
    000101_1010111010    (??? libc のライブラリ内に見られる)
       ~~~ ~~~
となります。

　これらより、(素直に)アセンブルされたこれらのコードの未使用レジスタフィールド
は
    ・もう片方のレジスタフィールドと同じ値
    ・0
の、どちらかであると思われます。

　さて、この未定義レジスタフィールドを上の2つのどちらかであろうと決めつけ、そ
れ以外であれば未定義命令としてしまえば、データ領域とプログラム領域の判別に役立
ちます。そのためのオプションが -R オプションです。

　-R に続く数値の第0ビットが1ならば、 これらの命令について上記のようなチェック
を行い、おかしければデータ領域と見なします。


●未使用レジスタフィールド(cinva, cpusha)

　CINV、CPUSH 命令にはアドレスレジスタを指定する為のフィールドがありますが、
cinv[lp]、cpush[lp] 命令でのみ使用され、cinva、cpusha 命令では未使用となってい
ます。

　この未使用フィールドには通常0が入るため、前述の ftst.x FPn などと同様のチェ
ックが行えます。

　オプションの指定も共通で、-R に続く数値の第0ビットが1ならば、 これらの命令に
ついてチェックを行い、おかしければデータ領域と見なします。


●サプレスされたレジスタ

　拡張アドレッシングは、ベースディスプレースメント、アウタディスプレースメン
ト、ベースレジスタ、インデックスレジスタを任意にサプレス(省略)することができま
す。サプレスされたレジスタについては、レジスタ名の前に'z'を付けることで表現し
ます。

    (例)
    asm     move.l  ([label1],label2),([label3,a1],label4)
    dis →  move.l  ([label1,za0,zd0.w],label2),([label3,a1,zd0.w],label4)

    asm     move.l  (d0.l),d1
    dis →  move.l  (za0,d0.l),d1

　ここでも、素直にアセンブルされたコードは、サプレスされたレジスタ番号に0以外
を指定したり、スケーリングやロングワードサイズの指定をしたりすることはないであ
ろうという経験的憶測のもとに、-R スイッチでそれについてのチェックの有無を指定
できます。

　-R に続く数値の、

　第1ビットが1ならば、サプレスされたレジスタ番号が0以外な場合、未定義命令とし
てデータ領域と見なします。

　第2ビットが1ならば、サプレスされたインデックスレジスタに対してスケーリングが
指定されている場合、未定義命令と見なします。

　第3ビットが1ならば、サプレスされたインデックスレジスタに対するサイズ指定がロ
ングワード(.l)ならば、未定義命令と見なします。

　これらの3つが指定された場合は、サプレスされたインデックスレジスタは表記その
ものを省略して出力します。まとめると以下のようになります。

・-R 14  (2+4+8=14) な場合

    命令 code                      命令の解釈     dis の出力

    ([label1,za0,zd0.w],label2)    有効           ([label1,za0],label2)
    ([label1,za0,zd0.w*2],label2)  無効(scaling)  データ領域として出力
    ([label1,za0,zd0.l],label2)    無効(size)     データ領域として出力

　このようにインデックスレジスタは表記が省略されます。

・どれも指定しなかった場合

    ([label1,za0,zd0.w],label2)    有効  ([label1,za0,zd0.w],label2)
    ([label1,za0,zd0.w*2],label2)  有効  ([label1,za0,zd0.w*2],label2)
    ([label1,za0,zd0.l],label2)    有効  ([label1,za0,zd0.l],label2)

　このよーなひねくれた(^^;)表現で出力します。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        ソースコードの再現性

───────────────────────────────────────

　アセンブルしてリンクした後、fc などのバイナリファイル比較ツールで比べてみる
ことをお勧めします。

　dis の制限またはオプション指定により違いが出ることがあります。それ以外で違い
があれば、それは dis のバグです。作者に報告して下さい。


●シンボルテーブル

　シンボルテーブルは -s1 オプションを指定するよりも -s2 を指定した方が再現性が
高くなりますが、それでも完全には再現できないため違いが生じることがあります。


●ソースコードデバッガ情報

　ソースコードデバッガ情報は全く再現できません。


●ワードサイズの再配置情報

　実行ファイルの再配置情報は普通ロングワード単位での処理を行いますが、実はワー
ド単位で処理を行う形式も用意されています。しかし、dis はそのようなワード単位の
再配置情報には対応していません。一応通常のロングワードサイズのそれと同じように
解釈し、また、最悪の場合でもアドレスエラーにはならないようにはしています。現在
のところワード単位の再配置情報を処理できるのは Human68k の DOS _EXEC ファンク
ションコールのコードだけで、アセンブラやリンカに対応しているものがないので、
dis が対応していなくても特に問題はないと思います。


●不定バイト(-f オプション指定時)

　不定バイトが $00 または $ff でない場合、それをアセンブラに指定する方法がない
ため再現できません。


●未使用レジスタフィールド(-R 第0ビット=0)

　未使用レジスタフィールドが0でない場合、それをアセンブラに指定する方法がない
ため再現できません。


●アドレッシングモード (bd,An,Xn), (bd,PC,Xn)

　実効アドレスがインデックス付きアドレス・レジスタ間接(ベース・ディスプレース
メント)モードでベース・ディスプレースメントが省略されている場合、インデックス
付きアドレス・レジスタ間接(8ビット・ディスプレースメント)モードとして出力され
ます。ベースレジスタが PC の場合も同様です。

　ベース・ディスプレースメントの省略を HAS 系統のアセンブラに指定する方法がな
いため再現できません。

    (例)
        .dc     $3030,$0000    ;move ($00,a0,d0.w),d0
        .dc     $3030,$0110    ;move ([BD省略],a0,d0.w),d0
        .dc     $303b,$0000    ;move ($00,pc,d0.w),d0
        .dc     $303b,$0110    ;move ([BD省略],pc,d0.w),d0
        ↓
        move    (a0,d0.w),d0
        move    (a0,d0.w),d0
        move    (Lxxxxxx+2,pc,d0.w),d0
        move    (pc,d0.w),d0


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        備考

───────────────────────────────────────

● dis の生成したソースファイルに関して

　dis の生成したソースファイルの著作権は、元の実行ファイルの著作者にあると思わ
れるので取り扱いには十分注意して下さい。


●バインドファイルについて

　実行ファイルがバインドされている場合、警告を出力して終了します。ソースジェネ
レートするためには unbind でバインドファイルを展開して下さい。


●スタックオーバーフロー

　dis は関数の再帰呼び出しを多用した解析処理を行いますが、その途中でスタックが
足りなくなった場合は「libc: stack overflow.」(X680x0 版の実行ファイルの場合)と
表示して強制終了します。オプションに -+-s:524288 などとやってみて下さい(デフォ
ルトは 256KB です)。


●特殊な状況

　素直にプログラムとして認識できない実行ファイルの場合、「xxxxxx : PC が有効な
セクションを外れた」というメッセージが繰り返し表示されて先に進まないように見え
ることがあります。そのような場合でも、無限ループにはなっていないはずなので、し
ばらくの間待ってみて下さい。dis が気の済むまで出力した後、正常に終了すると思い
ます。

　もし長時間待ってみても終了しないようなら、それは dis の不具合です。サポート
担当者に報告して下さい。


●浮動小数点

　拡張精度浮動小数点を実数表記で出力する場合は、大量の浮動小数点演算を行ってい
るので非常に処理時間が掛かります。演算は常にソフトウェアでエミュレートしている
ので、FPU を使用できる環境であってもあまり速くはなりません。

　処理の遅さに我慢できないようであれば、--inreal オプションを指定して全て内部
表記で出力するようにして下さい。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        仕様(メモとも言う)

───────────────────────────────────────

●対応プロセッサ

    68000/68008/68010/68020/68030/68040/68060
    68881/68882
    68040 内蔵 FPU
    68060 内蔵 FPU
    68851
    68030 内蔵 MMU
    68040 内蔵 MMU
    68060 内蔵 MMU
    040FPSP
    060ISP/060FPSP
    CPU32

    ※-m68008 指定時は -m68000 が指定されたものとして扱われます。また、Target
      MPU に表示されることはありません。-mcpu32 は CPU32 の追加命令を認識する
      だけで、アドレッシングモード等は -m680*0 の指定が採用されます。こちらも
      Target MPU には表示されません。


●実行形式の判別

　指定されたファイルがどの種類の実行ファイルかの判別は以下の順で行われます。

    1) -z オプション指定時              R形式
    2) *.r                              R形式
    3) ファイルの先頭2バイトが 'HU'     X形式
    4) ファイルの先頭2バイトが 0x601a   Z形式
    5) 上記条件に一致しない             エラー


●参照されないラベル

　全く参照されないラベルが出力される場合がありますが、気にしないで下さい。

　C コンパイラの出力で、

    static char ary[100];
    int index, a = ary[ index - 10 ];

などの時、GCC などは

    lea.l   (_ary-10),a0
    move.b  (a0,d0.l),d0        ;d0 = index;
    ext.w   d0
    ext.l   d0

のようなコードを出力しますが、dis はそんなことは知らずに、_ary-10 がどこにあろ
うとそこにラベルを振ろうとします。たまたま _ary-10 がプログラムの途中だったり
すると、命令の中を指すラベルのように見えます。このとき -k オプション等を指定し
ているとそこがデータの塊になったりします。-k オプションを用いる時は、なるべく
-k オプションなしで出力したファイルと比較して、ユーザーが適宜選択するようにし
て下さい。

　また、GCC でコンパイルされたものはデータとプログラムが入り混じっているので、
データをプログラムと誤認することがしばしばあります。


●dis の限界

　データ領域がたまたまプログラム領域としても認識できる値の場合、周辺を巻き込ん
でプログラム領域にしてしまうことがあります。具体的には

            lea     (crlf,pc),a0
            bsr     foo
            rts
    crlf:   .dc.b   13,10
            .even
    foo:
            nop
            rts

というコードを

    L000000:
            lea     (L000008,pc),a0
            bsr     L000008+2
            rts

    L000008:
            movep   ($4e71,a2),d6
            rts

と逆アセンブルしてしまいます。この時、foo は命令の中を指すラベルとして crlf+2
に置換されています。これは、「crlf がデータで foo がプログラム」なのか「crlf
がプログラムで foo は命令中を指すラベル」なのか dis には判別できないために起こ
ります。これもまた dis の限界ですが、この場合はラベルファイルで

000008  dsf
00000a  pf

と指定すれば期待通りに逆アセンブルされます。


●その他の細かい仕様

　解析中の文字列の表示は標準エラー出力へ出力されています。-q option を指定する
と処理が速くなります。テーブルを多用している場合は -q1 を指定しましょう。

　以下のファンクションコールがリターンしないということは(GCC でいう関数の
noreturn 属性)、ハードコーディングしてあります。
    DOS  _EXIT
    DOS  _EXIT2
    DOS  _KEEPPR
    DOS  _KILLPR
    SXCALL  ExitToShell

　64ビット整数(.q)は倍精度実数の内部表現と同じ形式で出力されます。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        用語解説

───────────────────────────────────────

実行ファイル
    　アセンブラソースを生成しようとしているファイルで、.x、.r、.z 形式実行フ
    ァイル、単なるバイナリファイルのいずれか。

命令の中を指すラベル
    　dis がサポートしている命令の中を指すラベルとは、下のようなものです。高速
    化や省メモリを狙ったプログラムや手抜きプログラム等で用いられる手法です(プ
    ログラムが分りにくくなるので、そのようなコーディングは勧めません)。

    label:
            move.w  #$0000,d0
            .................
            move.w  d1,(label+$000002)

    　この場合、dis は下のようなソースを出力します。

    L??????:
            move.w  #$0000,d0
            .................
            move.w  d1,(L??????+2)

    　少し違いますが、as.x の中では、命令のイミディエイトオペランドの中へジャ
    ンプすると言うテクニックが使われていて、その場合も命令の中を指すラベルが生
    成されます。

不定バイト
    　オペレーションサイズがバイト(.b)の命令で、かつソースオペランドがイミディ
    エイトデータの場合、命令の第3バイトは定義されていません(不定バイト)。しか
    し、as.x を使っている限りこの第3バイトは $00 か $ff のどちらかのようなの
    で、通常 dis はここをチェックして $00 か $ff のどちらでもなければ未定義命
    令にしてしまいます。as.x では、ソース中でイミディエイトデータを正として扱
    っているなら不定バイトは $00、負なら $ff になるようです。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        謝辞

───────────────────────────────────────

　dis を生み出だした K.Abe 氏と、それを成長させた R.ShimiZu 氏に感謝します。

　無限ループのバグを報告し、確実に再現する方法(重要)を提供して下さった Schmidt
氏に感謝します。

　bf 命令のエンバグの報告と、絶対ショート/ロングアドレッシング表記の情報を下さ
った鎌田氏に感謝します。

　XC ver 1.01 のインクルードファイルを送っていただいたラキッ！氏に感謝します。

　奇数アドレスへの分岐とサブルーチンコール命令の直後の引数への対応は、松戸のロ
イヤルホストでひたすらオレンジジュースを待った三人の会話がきっかけで実現しまし
た。

　FreeBSD クロス版のソース差分を送っていただき、ベータ版の動作試験にも協力して
いただいた M.Suzuki 氏に感謝します。

　CygWin への対応にあたって、RuRuRu 氏の Win32 移植版を参考にさせていただきま
した。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        開発環境

───────────────────────────────────────

gcc version 2.6.3 (68k, Human68k, revision 5)
                                        FSF / Charlie / KQ
HAS060 version 3.09+87+15[g2as]         Y.Nakamura / M.Kamada / 立花
HLK evolution version 3.01+14[g2lk]     SALT / 立花
GNU Make version 3.79 human68k-1.2      FSF (自分で移植版)
GNU diffutils version 2.7 human68k-1.3  FSF (〃)
MicroEMACS j1.43 (rel.5c7-beta4)        Sharl 他

libc-1.2.20 Release Mimu                Project C Library Group / 立花
libgcc version x.xx patchlevel 7        FSF / Charlie / 立花
libhdi ver2.9 (改)                      oo / 立花
libhmem ver1.10b                        oo
libld (level 1)                         立花

(敬称略)


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        連絡先

───────────────────────────────────────

TcbnErik / 立花@桑島技研
https://github.com/kg68k/dis


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

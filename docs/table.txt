［テーブル記述ファイルについて］

  dis はオートでは、テーブルを認識することは(リラティブオフセットテーブ
ルを除いて)出来ません。そこで、テーブルの形をユーザーが記述して dis に教
えてやろうというのがテーブル記述ファイルです。
  テーブル記述ファイルを使うには、アセンブリプログラムを読む力とテーブル
の構造を見切る力が必要です。アセンブラ初心者には使えないかも知れません。
  テーブル記述ファイルを間違って記述すると、ソースも間違って生成されます
ので注意して下さい。
  テーブル記述ファイルを使う時はラベルファイルを読み込むので、-e option 
で作っておいて下さい。ラベルファイルのパスを与えたければ -e option でで
きます。


  例を挙げて説明します。以下のようなプログラム(の一部)があるとします。

--- リスト EX1.S ---
1: * ex1.s
2: table:
3: 	dc.b	1		* データ
4: 	dc.b	'dir',0		* 0で終わる文字列(asciiz)
5: 	.even			* ワード境界へ
6: 	dc.w	dir_com-table	* 処理アドレス(テーブル先頭からのオフセ
7: 				* ット)
8: 	dc.b	2
9: 	dc.b	'type',0
10: 	.even
11: 	dc.w	type_com-table
12: 
13: 	dc.b	3
14: 	dc.b	'exit',0
15: 	.even
16: 	dc.w	exit_com-table
17: 
18: dir_com:
19: 	rts
20: type_com:
21: 	rts
22: exit_com:
23: 	rts

  dis でオートでソースジェネレートしてみると、

--- リスト DIS_EX1.S その１ ---
1: L000000:
2: 	.dc.b	$01,$64,$69,$72,$00,$00,$00,$18
3: 	.dc.b	$02,$74,$79,$70,$65,$00,$00,$1a
4: 	.dc.b	$03,$65,$78,$69,$74,$00,$00,$1c
5: 	.dc.b	$4e,$75,$4e,$75,$4e,$75

　このようにオートではこのようなテーブルはデータの塊として出力してしまい
ますが、以下のようなテーブル記述ファイルを作ることによりきれいな逆アセン
ブルソースを得られます。

--- リスト EX1.TAB その１ ---
1: * ex1.tab
2: 0				# 0 はテーブルの開始アドレス(16進数)
3: 	dc.b			# バイトデータ
4: 	asciiz			# 0 で終わる文字列の出力
5: 	even			# .even の出力
6: 	dc.w			# ワードデータ
7: end[3]			# 以上の物が３つ(10進数)

上のテーブル記述ファイルを -T option で読み込ませますが、その時ラベルファイル
も読み込むので、一度 -e option でラベルファイルを作っておきます。
	dis ex1.x foo.s -e
そして、
	dis ex1.x foo.s -T
とします。以下のようなファイルが生成される筈です。(右のアドレスは -a
option で出力)

--- リスト DIS_EX1.S その２ ---
1: L000000:					* 0
2: 	.dc.b	1				* 0
3: 	.dc.b	'dir',$00			* 1
4: 	.even					* 5
5: 	.dc.w	$18				* 6
6: 	.dc.b	2				* 8
7: 	.dc.b	'type',$00			* 9
8: 	.even					* e
9: 	.dc.w	$1a				* e
10: 	.dc.b	3				* 10
11: 	.dc.b	'exit',$00			* 11
12: 	.even					* 16
13: 	.dc.w	$1c				* 16
14: L000018:					* 18
15: 	rts					* 18
16: 
17: L00001a:					* 1a
18: 	rts					* 1a
19: 
20: L00001c:					* 1c
21: 	rts					* 1c
22: 	...

　だいぶましになりましたが、5, 9, 13 行の dc.w を元のソースのように出力
したいところです。以下のように ex1.tab を書き換えます

--- リスト EX1.TAB その２ ---
1: * ex1.tab
2: 0				# 0 はテーブルの開始アドレス(16進数)
3: 	dc.b			# バイトデータ
4: 	asciiz			# 0 で終わる文字列
5: 	even			# .even の出力
6: 	dc.w	{peek.w(pc)+tabletop},"-",{tabletop}	# なんだ？これは！
7: end[3]			# 以上の物が３つ(10進数)

６行目が変わっています。最小限の説明をすると、

	{ 式 }		式のアドレスのラベルを表します。式の値が 0 なら、
			出力ソース中では L000000 に置換されます。(シンボ
			ルテーブルがあればそのシンボル)
	"文字列"	出力ソース中に文字列が( '"' を取り去って)そのま
			ま挿入されます。

	以下、式の構成要素

	tabletop	テーブルの開始アドレスを保持しています。上の例で
			は値は 0 になります。

	pc		注目しているアドレスを保持しています。

	peek.w( 式 )	式のアドレスの指すワード値を保持します。
			Ｃでいう、*(unsigned short*)式 のことです。

　これで EX1.TAB その２の６行目が解読出来ます。リスト EX1.S その２ の５
行目で考えてみると、
  ( 5: 	.dc.w	$18				* 6 )
  ここで、pc = $6 , peek.w(pc)= $18 , tabletop = 0 ですから、
peek.w(pc)+tabletop の値は $18 になり、{peek.w(pc)+tabletop}は L000018 
に置換されます。文字列の "-" で、- が入り、{tabletop} は L000000 に置換
され、結局 L000018-L000000 が結果として得られます。

　EX1.TAB その２をテーブル記述ファイルとして読み込ませると、以下のような
ファイルを生成する筈です。

1: L000000:					* 0
2: 	.dc.b	1				* 0
3: 	.dc.b	'dir',$00			* 1
4: 	.even					* 5
5: 	.dc.w	L000018-L000000			* 6
6: 	.dc.b	2				* 8
7: 	.dc.b	'type',$00			* 9
8: 	.even					* e
9: 	.dc.w	L00001a-L000000			* e
10: 	.dc.b	3				* 10
11: 	.dc.b	'exit',$00			* 11
12: 	.even					* 16
13: 	.dc.w	L00001c-L000000			* 16
14: L000018:					* 18
15: 	rts					* 18
16: 
17: L00001a:					* 1a
18: 	rts					* 1a
19: 
20: L00001c:					* 1c
21: 	rts					* 1c
22: 	...

  これでわかりやすいソースを得られました。もし幸運なことに ex1.x にシン
ボルテーブルが付いていたら以下のようなソースになることは明らかでしょう。

1: table:						* 0
2: 	.dc.b	1				* 0
3: 	.dc.b	'dir',$00			* 1
4: 	.even					* 5
5: 	.dc.w	dir_com-table			* 6
6: 	.dc.b	2				* 8
7: 	.dc.b	'type',$00			* 9
8: 	.even					* e
9: 	.dc.w	type_com-table			* e
10: 	.dc.b	3				* 10
11: 	.dc.b	'exit',$00			* 11
12: 	.even					* 16
13: 	.dc.w	exit_com-table			* 16
14: dir_com:					* 18
15: 	rts					* 18
16: 
17: type_com:					* 1a
18: 	rts					* 1a
19: 
20: exit_com:					* 1c
21: 	rts					* 1c


別の例として、以下のようなプログラムを考えます。

--- リスト EX2.S ---
1: * ex2.s
2: table:
3: 	dc.l	proc_apple		* アドレス
4: 	dc.b	'apple '		* ６文字の文字列
5: 	dc.w	1,2,3			* ３つのワードデータ
6: 
7: 	dc.l	proc_dec
8: 	dc.b	'dec   '
9: 	dc.w	2100,3100,6100
10: 
11: 	dc.l	proc_sun
12: 	dc.b	'sun   '
13: 	dc.w	1,2,3
14: 
15: 	dc.l	0			* テーブル終わりのしるし
16: 
17: proc_apple:
18: 	rts
19: proc_dec:
20: 	rts
21: proc_sun:
22: 	rts

　これをオートでソースジェネレートすると、以下のようになります。

1: L000000:
2: 	.dc.l	L000034
3: L000004:
4: 	.dc.b	'apple ',$00
5: L00000b:
6: 	.dc.b	$01,$00,$02,$00,$03
7: 	.dc.l	L000036
8: 	.dc.b	$64,$65,$63,$20,$20,$20,$08,$34
9: 	.dc.b	$0c,$1c,$10,$04
10: 	.dc.l	L000038
11: L000024:
12: 	.dc.b	'sun   ',$00
13: L00002b:
14: 	.dc.b	$01,$00,$02,$00,$03,$00,$00,$00
15: 	.dc.b	$00
16: L000034:
17: 	rts
18: 
19: L000036:
20: 	rts
21: 
22: L000038:
23: 	rts
24: 	...

  テーブル記述ファイルは以下のようになります。
--- リスト EX2.TAB その１ ---
1: 0				# テーブル開始アドレス(16進)
2: 	dc.l			# ロングワードデータ
3: 	break	peek.l(pc-4)==0	# 条件が満たされたらテーブル終わり
4: 	ascii[6]		# ６文字の文字列
5: 	dc.w[3]			# ３つのワードデータ
6: 	cr			# ここで改行する
7: end[3]			# 以上の物が３つ(10進)

　３行目に break がありますが、これは break のあるところでテーブルが打ち
切られる可能性があることを示します。一般形は
	break	式
で、式の値が０でなければそこでテーブルを打ち切ります。
  また、６行目の cr は出力ファイルを見易くするために改行を入れるための物
です。


［テーブル記述ファイルの文法］

  # または * で始まる行はコメントと見なされます。# と * は今のところ行頭
にしか書けません。(手抜きな仕様だ...)

  テーブル記述ファイルは以下のブロックを並べたファイルです。

	テーブル開始アドレス(16進)
		識別子	オペランド表現式
		......
	テーブル終了マーク

  識別子  オペランド表現式 は一行に書かなければなりません。


  'テーブル開始アドレス'は16進で、行頭になければなりません。

  '識別子'は以下のいずれかで、大文字小文字を区別しません。
	dc.b
		１バイトのデータを dc.b で出力します。
		後に'オペランド表現式'があれば、その式を出力します。
	dc.w
		１ワードのデータを dc.w で出力します。
		後に'オペランド表現式'があれば、その式を出力します。
	dc.l
		１ロングワードのデータを dc.l で出力します。
		後に'オペランド表現式'があれば、その式を出力します。
		アドレスに依存したデータは dc.l で出力しなければなりませ
		ん。
		オペランド表現式がなければ、自動でアドレスに依存してい
		るかどうかを判断します。
	byte[ 式 ]
		'式'バイトのバイト列を dc.b で出力します。
	asciiz
		０で終わる文字列を dc.b で出力します。
	lascii
		文字数 + 文字列 の形の文字列を dc.b で出力します。
		SX-Window でよく用いられるようです。
	ascii[ 式 ]
		'式'バイトの文字列を dc.b で出力します。

	even
		.even 疑似命令を出力します。
	cr
		改行します。
	break 式
		式の値が０でなければテーブルを終了します。

    byte と ascii 以外の識別子の後に [ 式 ] を付けた場合、式の値だけ識別
    子を繰り返したのと同じになります。たとえば、
	dc.b	5,'print'
	dc.b	4,'list'
	dc.b	3,'run'
	dc.b	4,'goto'
    のようなデータ構造に、
	dc.b
	ascii[ peek.b(pc-1) ]
    のように使えます。( これは 識別子 lascii と同じことです )


  'オペランド表現式'は dc.? のオペランドを与えるためのものです。
  オペランド表現式の形式は
	'式' または '文字列' , '式' または '文字列' , ....
　です。
　式の周りを '{' '}' で囲むと、それは式のアドレスのラベルを意味すること
になり、生成ソース中では L?????? の形式、またはシンボル名に置換されます。
囲まなければただの数値として $?????? の形式で生成ソース中に挿入されます。
文字列はそのまま、生成ソースに挿入されます。
  例えば、
	dc.w	{peek.w(pc)+tabletop}, "-"  ,{tabletop}
/*	識別子	{式}                 ,文字列,{式}	*/
  は生成ソース中では dc.w L??????-L?????? の形になります。

  オペランド表現式は、文字列を普通の演算子と見なして値が peek.?(pc) にな
らなければいけません。例えば、
	dc.w	{peek.w(pc)+tabletop}, "-"  ,{tabletop}
  は、文字列 "-" を - とみなすと、
	peek.w(pc)+tabletop - tabletop = peek.w(pc)
  なので、このオペランド表現式はあっています。


  '式'はＣの式のサブセットが使えます。
	算術演算子
		+	-	*	/	%
	論理演算子
		==	!=	<	<=	>	>=
		!
	その他
		( )		かっこも使用出来ます。
	定数
		tabletop	テーブルの先頭アドレスを保持しています。
		pc		注目中のアドレスを保持しています。
	関数
		peek.b(式)	式のアドレスの指すバイト値を保持します。
				*(unsigned char*)式 のことです。
		peek.w(式)	式のアドレスの指すバイト値を保持します。
				*(unsigned word*)式 のことです。
		peek.l(式)	式のアドレスの指すバイト値を保持します。
				*(unsigned long*)式 のことです。
		ext.w(式)	式をsigned charと見なし、unsigned short に
				符号拡張します。
				(unsigned short)(unsigned char)式 のことです。
		ext.l(式)	式をsigned shortと見なし、unsigned long に
				符号拡張します。
				(unsigned long)(unsigned short)式 のことです。
		.w 等は省略不可能です。
		奇数アドレスからの peek.w peek.l 等も出来ますが、警告が
		出ます。

	文字列
		"文字列"	文字列を与えます。

	演算はすべて unsigned long で行われます。peek.?(?)<0 は常に偽となりま
	す。


　'数'は 10進数と、頭に '$'をつけた16進数が使えます。


  'テーブル終了マーク'は、以下のいずれかで、行頭になければなりません。
	end		以上のテーブルが１つあることを指定します。
	end[(10進)数]	以上のテーブルが '数'個あることを指定します。
	end[]		以上のテーブルが複数個あって、テーブルの数は
			dis が適当に判断します。(break文があればそれもみ
			ます)
	end[breakonly]	以上のテーブルが複数個あって、テーブルの数は
			break 文でのみ判断します。break文を書かないと止
			まりませんので注意して下さい。

    テーブルの数が分かる時はなるべく end[ 数 ] を使用して下さい。end[] 
    の自動判断はテーブルの次のラベルのアドレスやアドレスに依存していると
    ころ等をみて判断しているだけなのでしばしば間違えます。特に文字列認識
    の時に不用なラベルを作ってしまうのでよくそれに引っ掛かります。break
    文を書いても break文に引っ掛かる前に dis が勝手にテーブルを終わらせ
    てしまうときに end[breakonly] を使用して下さい。


［テーブル記述ファイルの限界］

　当然ながら、全てのパターンのテーブルを記述することは不可能です。
例えば、
	・文字列の最後を '\0' で示さずに、MSB を 1 にするなどの方法で
	  持っているテーブル。
	・動的にテーブルの形が変わるテーブル。
	・ポインタの値を追いかけるようなテーブル。(リストだ...)


［より正確な文法］
  分かる人だけどうぞ。はっきりいって bison(yacc) を使ったのは初めてなの
でまぬけな事をしています。(使ってみたかっただけです...)ほとんどが K&R 第
２版からの流用です。...

tabledesc	: BREAK expr
		| sizeid
		| sizeid '[' expr ']'
		| sizeid exprstring
		| sizeid '[' expr ']' exprstring
		;

sizeid		: SIZEID
		| '@' SIZEID		/* いまのとこ意味無し */
		;

exprstring	: str_or_exp
		| exprstring ',' str_or_exp
		;

str_or_exp	: _STRING
		| expr
		| '{' expr '}'
		;

expr		: logical_AND_expr
		| expr OROR logical_AND_expr
		;

logical_AND_expr: equality_expr
		| logical_AND_expr ANDAND equality_expr
		;

equality_expr	: relational_expr
		| equality_expr EQUEQU relational_expr
		| equality_expr NOTEQU relational_expr
		;

relational_expr	: additive_expr
		| relational_expr '<' additive_expr
		| relational_expr LE additive_expr
		| relational_expr '>' additive_expr
		| relational_expr GE additive_expr
		;

additive_expr	: mul_expr
		| additive_expr '+' mul_expr
		| additive_expr '-' mul_expr
		;

mul_expr	: factor
		| mul_expr '*' factor
		| mul_expr '/' factor
		| mul_expr '%' factor
		;

factor		: '-' factor
		| '!' factor
		| element
		;

element		: '(' expr ')'
		| NUMBER
		| PEEKB '(' expr ')'
		| PEEKW '(' expr ')'
		| PEEKL '(' expr ')'
		| EXTW '(' expr ')'
		| EXTL '(' expr ')'
		;


(EOF)
